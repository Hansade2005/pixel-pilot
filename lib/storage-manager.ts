// Universal storage manager that works on both client and server
// Uses IndexedDB on client-side and in-memory storage on server-side

import { emitStorageEvent, withStorageEvents } from './storage-events'

// Core interfaces (same as IndexedDB)
export interface Workspace {
  id: string
  name: string
  description?: string
  slug: string
  userId: string
  isPublic: boolean
  isTemplate: boolean
  isPinned?: boolean
  lastActivity: string
  // Deployment tracking
  githubRepoUrl?: string
  githubRepoName?: string
  vercelProjectId?: string
  vercelDeploymentUrl?: string
  netlifySiteId?: string
  netlifyDeploymentUrl?: string
  deploymentStatus: 'not_deployed' | 'in_progress' | 'deployed' | 'failed'
  createdAt: string
  updatedAt: string
}

export interface File {
  id: string
  workspaceId: string
  name: string
  path: string
  content: string
  fileType: string
  type: string // Alias for fileType
  folderId?: string
  size: number
  isDirectory: boolean
  createdAt: string
  updatedAt: string
  metadata?: Record<string, any>
}

export interface ChatSession {
  id: string
  workspaceId?: string
  userId: string
  title: string
  isActive: boolean
  lastMessageAt: string
  messageCount?: number
  endedAt?: string
  createdAt: string
  updatedAt: string
}

export interface Message {
  id: string
  chatSessionId: string
  role: 'user' | 'assistant' | 'system'
  content: string
  metadata: Record<string, any>
  tokensUsed: number
  createdAt: string
}

// Checkpoint interface for storing file state snapshots
export interface Checkpoint {
  id: string
  workspaceId: string
  messageId: string // Reference to the user message that triggered this checkpoint
  files: Array<{
    path: string
    content: string
    name: string
    fileType: string
    size: number
    isDirectory: boolean
  }>
  createdAt: string
  label?: string // Optional label for the checkpoint
}

// Conversation memory interface for persistent chat history
export interface ConversationMemory {
  id: string
  projectId: string
  userId: string
  messages: Array<{
    role: 'user' | 'assistant' | 'system'
    content: string
    timestamp: string
    toolCalls?: any[]
    toolResults?: any[]
  }>
  summary: string
  keyPoints: string[]
  lastActivity: string
  createdAt: string
  updatedAt: string
  // AI-enhanced memory fields
  aiInsights?: string[]
  semanticSummary?: string
  technicalPatterns?: string[]
  architecturalDecisions?: string[]
  nextLogicalSteps?: string[]
  potentialImprovements?: string[]
  relevanceScore?: number
  contextForFuture?: string
}

// Conversation summary interface for Codestral-generated structured summaries
export interface ConversationSummary {
  id: string
  projectId: string
  userId: string
  // Structured summary generated by Codestral
  summary: {
    conversationOverview: string
    fileOperationsLog: Array<{
      path: string
      operations: Array<{
        type: 'created' | 'updated' | 'deleted'
        content?: string
        reason?: string
        status: 'success' | 'failed'
        error?: string
      }>
      finalState: 'present' | 'deleted' | 'failed'
    }>
    activeWorkState: {
      currentFocus: string
      recentCommands: string[]
    }
    pendingSteps: string[]
  }
  createdAt: string
  updatedAt: string
}

export interface Deployment {
  id: string
  workspaceId: string
  url: string
  status: 'ready' | 'building' | 'error' | 'cancelled'
  createdAt: string
  commitSha?: string
  commitMessage?: string
  branch?: string
  environment: string
  externalId?: string
  provider: 'vercel' | 'netlify' | 'github'
}

export interface TokenEntry {
  id: string
  userId: string
  provider: string // 'github' | 'vercel' | 'netlify'
  token: string
  createdAt: string
  updatedAt: string
}

export interface EnvironmentVariable {
  id: string
  workspaceId: string
  key: string
  value: string
  environment: string
  isSecret: boolean
  createdAt: string
  updatedAt: string
}

// Tool execution tracking interface for preventing duplicate executions
export interface ToolExecution {
  id: string
  workspaceId: string
  toolName: string
  args: Record<string, any>
  status: 'pending' | 'executing' | 'completed' | 'failed'
  result?: any
  error?: string
  startTime: number
  endTime?: number
  messageId?: string // Reference to the message that triggered this execution
  createdAt: string
  updatedAt: string
}

// Storage interface for type safety
export interface StorageInterface {
  createWorkspace(workspace: Omit<Workspace, 'id' | 'createdAt' | 'updatedAt'>): Promise<Workspace>;
  getWorkspace(id: string): Promise<Workspace | null>;
  getWorkspaces(userId: string): Promise<Workspace[]>;
  updateWorkspace(id: string, updates: Partial<Workspace>): Promise<Workspace | null>;
  deleteWorkspace(id: string): Promise<boolean>;
  createFile(file: Omit<File, 'id' | 'createdAt' | 'updatedAt'>): Promise<File>;
  getFile(workspaceId: string, path: string): Promise<File | null>;
  getFiles(workspaceId: string): Promise<File[]>;
  updateFile(workspaceId: string, path: string, updates: Partial<File>): Promise<File | null>;
  deleteFile(workspaceId: string, path: string): Promise<boolean>;
  createChatSession(session: Omit<ChatSession, 'id' | 'createdAt' | 'updatedAt'>): Promise<ChatSession>;
  getChatSessions(userId: string): Promise<ChatSession[]>;
  getChatSession(id: string): Promise<ChatSession | null>;
  updateChatSession(id: string, updates: Partial<ChatSession>): Promise<ChatSession | null>;
  createMessage(message: Omit<Message, 'id' | 'createdAt'>): Promise<Message>;
  getMessages(chatSessionId: string): Promise<Message[]>;
  deleteMessage(chatSessionId: string, messageId: string): Promise<boolean>;
  createDeployment(deployment: Omit<Deployment, 'id' | 'createdAt'>): Promise<Deployment>;
  getDeployments(workspaceId?: string): Promise<Deployment[]>;
  updateDeployment(id: string, updates: Partial<Deployment>): Promise<Deployment | null>;
  deleteDeployment(id: string): Promise<boolean>;
  createEnvironmentVariable(envVar: Omit<EnvironmentVariable, 'id' | 'createdAt' | 'updatedAt'>): Promise<EnvironmentVariable>;
  getEnvironmentVariables(workspaceId?: string): Promise<EnvironmentVariable[]>;
  updateEnvironmentVariable(id: string, updates: Partial<EnvironmentVariable>): Promise<EnvironmentVariable | null>;
  deleteEnvironmentVariable(id: string): Promise<boolean>;
  // Token methods (for storing provider tokens client-side)
  createToken(token: Omit<TokenEntry, 'id' | 'createdAt' | 'updatedAt'>): Promise<TokenEntry>;
  getToken(userId: string, provider: string): Promise<TokenEntry | null>;
  updateToken(id: string, updates: Partial<TokenEntry>): Promise<TokenEntry | null>;
  deleteToken(id: string): Promise<boolean>;
  
  // Checkpoint methods for versioning and revert functionality
  createCheckpoint(checkpoint: Omit<Checkpoint, 'id' | 'createdAt'>): Promise<Checkpoint>;
  getCheckpoints(workspaceId: string): Promise<Checkpoint[]>;
  getCheckpoint(id: string): Promise<Checkpoint | null>;
  deleteCheckpoint(id: string): Promise<boolean>;
  restoreCheckpoint(checkpointId: string): Promise<boolean>;
  
  // Conversation memory methods for persistent chat history
  createConversationMemory(memory: Omit<ConversationMemory, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationMemory>;
  getConversationMemory(projectId: string, userId: string): Promise<ConversationMemory | null>;
  updateConversationMemory(id: string, updates: Partial<ConversationMemory>): Promise<ConversationMemory | null>;
  deleteConversationMemory(id: string): Promise<boolean>;
  
  // Conversation summary methods for Codestral-generated summaries
  createConversationSummary(summary: Omit<ConversationSummary, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationSummary>;
  getConversationSummary(projectId: string, userId: string): Promise<ConversationSummary | null>;
  updateConversationSummary(id: string, updates: Partial<ConversationSummary>): Promise<ConversationSummary | null>;
  deleteConversationSummary(id: string): Promise<boolean>;
  
  // Tool execution tracking methods for preventing duplicate executions
  createToolExecution(execution: Omit<ToolExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<ToolExecution>;
  getToolExecution(id: string): Promise<ToolExecution | null>;
  getToolExecutions(workspaceId: string): Promise<ToolExecution[]>;
  updateToolExecution(id: string, updates: Partial<ToolExecution>): Promise<ToolExecution | null>;
  deleteToolExecution(id: string): Promise<boolean>;
  findExistingExecution(workspaceId: string, toolName: string, args: Record<string, any>): Promise<ToolExecution | null>;
  
  // Additional utility methods
  importTable(tableName: string, data: any[]): Promise<void>;
  
  clearAll(): Promise<void>;
  exportData(): Promise<any>;
}

// In-memory storage for server-side
class InMemoryStorage implements StorageInterface {
  private static instance: InMemoryStorage | null = null
  private tokens: Map<string, TokenEntry> = new Map()
  private workspaces: Map<string, Workspace> = new Map()
  private files: Map<string, File> = new Map()
  private chatSessions: Map<string, ChatSession> = new Map()
  private messages: Map<string, Message> = new Map()
  private deployments: Map<string, Deployment> = new Map()
  private environmentVariables: Map<string, EnvironmentVariable> = new Map()
  private checkpoints: Map<string, Checkpoint> = new Map() // Add checkpoints map
  private conversationMemories: Map<string, ConversationMemory> = new Map() // Add conversation memories map
  private conversationSummaries: Map<string, ConversationSummary> = new Map() // Add conversation summaries map
  private toolExecutions: Map<string, ToolExecution> = new Map() // Add tool executions map

  private constructor() {}

  static getInstance(): InMemoryStorage {
    if (!InMemoryStorage.instance) {
      InMemoryStorage.instance = new InMemoryStorage()
    }
    return InMemoryStorage.instance
  }

  // Workspace methods
  async createWorkspace(workspace: Omit<Workspace, 'id' | 'createdAt' | 'updatedAt'>): Promise<Workspace> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newWorkspace: Workspace = {
      ...workspace,
      id,
      createdAt: now,
      updatedAt: now
    }
    this.workspaces.set(id, newWorkspace)
    return newWorkspace
  }

  async getWorkspace(id: string): Promise<Workspace | null> {
    return this.workspaces.get(id) || null
  }

  async getWorkspaces(userId: string): Promise<Workspace[]> {
    return Array.from(this.workspaces.values()).filter(w => w.userId === userId)
  }

  async updateWorkspace(id: string, updates: Partial<Workspace>): Promise<Workspace | null> {
    const workspace = this.workspaces.get(id)
    if (!workspace) return null
    
    const updatedWorkspace: Workspace = {
      ...workspace,
      ...updates,
      updatedAt: new Date().toISOString()
    }
    this.workspaces.set(id, updatedWorkspace)
    return updatedWorkspace
  }

  async deleteWorkspace(id: string): Promise<boolean> {
    return this.workspaces.delete(id)
  }

  // File methods
  async createFile(file: Omit<File, 'id' | 'createdAt' | 'updatedAt'>): Promise<File> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newFile: File = {
      ...file,
      id,
      createdAt: now,
      updatedAt: now
    }
    this.files.set(id, newFile)
    return newFile
  }

  async getFile(workspaceId: string, path: string): Promise<File | null> {
    return Array.from(this.files.values()).find(f => f.workspaceId === workspaceId && f.path === path) || null
  }

  async getFiles(workspaceId: string): Promise<File[]> {
    return Array.from(this.files.values()).filter(f => f.workspaceId === workspaceId)
  }

  async updateFile(workspaceId: string, path: string, updates: Partial<File>): Promise<File | null> {
    const file = await this.getFile(workspaceId, path)
    if (!file) return null
    
    const updatedFile: File = {
      ...file,
      ...updates,
      updatedAt: new Date().toISOString()
    }
    this.files.set(file.id, updatedFile)
    return updatedFile
  }

  async deleteFile(workspaceId: string, path: string): Promise<boolean> {
    const file = await this.getFile(workspaceId, path)
    if (!file) return false
    return this.files.delete(file.id)
  }

  // Chat session methods
  async createChatSession(session: Omit<ChatSession, 'id' | 'createdAt' | 'updatedAt'>): Promise<ChatSession> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newSession: ChatSession = {
      ...session,
      id,
      createdAt: now,
      updatedAt: now
    }
    this.chatSessions.set(id, newSession)
    return newSession
  }

  async getChatSessions(userId: string): Promise<ChatSession[]> {
    return Array.from(this.chatSessions.values()).filter(s => s.userId === userId)
  }

  async getChatSession(id: string): Promise<ChatSession | null> {
    return this.chatSessions.get(id) || null
  }

  async updateChatSession(id: string, updates: Partial<ChatSession>): Promise<ChatSession | null> {
    const chatSession = this.chatSessions.get(id)
    if (!chatSession) return null
    
    const updatedChatSession: ChatSession = {
      ...chatSession,
      ...updates,
      updatedAt: new Date().toISOString()
    }
    this.chatSessions.set(id, updatedChatSession)
    return updatedChatSession
  }

  // Message methods
  async createMessage(message: Omit<Message, 'id' | 'createdAt'>): Promise<Message> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newMessage: Message = {
      ...message,
      id,
      createdAt: now
    }
    this.messages.set(id, newMessage)
    return newMessage
  }

  async getMessages(chatSessionId: string): Promise<Message[]> {
    return Array.from(this.messages.values())
      .filter(m => m.chatSessionId === chatSessionId)
      .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())
  }

  // Add deleteMessage function
  async deleteMessage(chatSessionId: string, messageId: string): Promise<boolean> {
    const message = this.messages.get(messageId);
    if (!message || message.chatSessionId !== chatSessionId) {
      return false;
    }
    return this.messages.delete(messageId);
  }

  // Deployment methods
  async createDeployment(deployment: Omit<Deployment, 'id' | 'createdAt'>): Promise<Deployment> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newDeployment: Deployment = {
      ...deployment,
      id,
      createdAt: now
    }
    this.deployments.set(id, newDeployment)
    return newDeployment
  }

  async getDeployments(workspaceId?: string): Promise<Deployment[]> {
    if (workspaceId) {
      return Array.from(this.deployments.values()).filter(d => d.workspaceId === workspaceId)
    }
    return Array.from(this.deployments.values())
  }

  async updateDeployment(id: string, updates: Partial<Deployment>): Promise<Deployment | null> {
    const deployment = this.deployments.get(id)
    if (!deployment) return null
    
    const updatedDeployment: Deployment = {
      ...deployment,
      ...updates
    }
    this.deployments.set(id, updatedDeployment)
    return updatedDeployment
  }

  async deleteDeployment(id: string): Promise<boolean> {
    return this.deployments.delete(id)
  }

  // Environment variable methods
  async createEnvironmentVariable(envVar: Omit<EnvironmentVariable, 'id' | 'createdAt' | 'updatedAt'>): Promise<EnvironmentVariable> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newEnvVar: EnvironmentVariable = {
      ...envVar,
      id,
      createdAt: now,
      updatedAt: now
    }
    this.environmentVariables.set(id, newEnvVar)
    return newEnvVar
  }

  async getEnvironmentVariables(workspaceId?: string): Promise<EnvironmentVariable[]> {
    if (workspaceId) {
      return Array.from(this.environmentVariables.values()).filter(e => e.workspaceId === workspaceId)
    }
    return Array.from(this.environmentVariables.values())
  }

  async updateEnvironmentVariable(id: string, updates: Partial<EnvironmentVariable>): Promise<EnvironmentVariable | null> {
    const envVar = this.environmentVariables.get(id)
    if (!envVar) return null
    
    const updatedEnvVar: EnvironmentVariable = {
      ...envVar,
      ...updates,
      updatedAt: new Date().toISOString()
    }
    this.environmentVariables.set(id, updatedEnvVar)
    return updatedEnvVar
  }

  async deleteEnvironmentVariable(id: string): Promise<boolean> {
    return this.environmentVariables.delete(id)
  }

  // Utility methods
  async clearAll(): Promise<void> {
    this.workspaces.clear()
    this.files.clear()
    this.chatSessions.clear()
    this.messages.clear()
    this.deployments.clear()
    this.environmentVariables.clear()
  }

  async exportData(): Promise<any> {
    return {
      workspaces: Array.from(this.workspaces.values()),
      files: Array.from(this.files.values()),
      chatSessions: Array.from(this.chatSessions.values()),
      messages: Array.from(this.messages.values()),
      deployments: Array.from(this.deployments.values()),
      environmentVariables: Array.from(this.environmentVariables.values())
  ,
  tokens: Array.from(this.tokens.values())
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36)
  }

  async init(): Promise<void> {
    // No initialization needed for in-memory storage
  }

  // Token methods for in-memory
  async createToken(token: Omit<TokenEntry, 'id' | 'createdAt' | 'updatedAt'>): Promise<TokenEntry> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newToken: TokenEntry = { ...token, id, createdAt: now, updatedAt: now }
    this.tokens.set(id, newToken)
    return newToken
  }

  async getToken(userId: string, provider: string): Promise<TokenEntry | null> {
    for (const t of Array.from(this.tokens.values())) {
      if (t.userId === userId && t.provider === provider) return t
    }
    return null
  }

  async updateToken(id: string, updates: Partial<TokenEntry>): Promise<TokenEntry | null> {
    const existing = this.tokens.get(id)
    if (!existing) return null
    const updated = { ...existing, ...updates, updatedAt: new Date().toISOString() }
    this.tokens.set(id, updated)
    return updated
  }

  async deleteToken(id: string): Promise<boolean> {
    return this.tokens.delete(id)
  }

  // Additional methods to match interface
  async exportTable(tableName: string): Promise<any[]> {
    switch (tableName) {
      case 'workspaces': return Array.from(this.workspaces.values())
      case 'files': return Array.from(this.files.values())
      case 'chatSessions': return Array.from(this.chatSessions.values())
      case 'messages': return Array.from(this.messages.values())
      case 'deployments': return Array.from(this.deployments.values())
      case 'environmentVariables': return Array.from(this.environmentVariables.values())
      case 'tokens': return Array.from(this.tokens.values())
      default: return []
    }
  }

  async importTable(tableName: string, data: any[]): Promise<void> {
    // In memory storage doesn't persist data, so we just populate the maps
    // This is primarily for testing and server-side operations
    if (!data || data.length === 0) return
    
    // Map table names to their respective maps
    const tableMap: Record<string, Map<string, any>> = {
      workspaces: this.workspaces,
      files: this.files,
      chatSessions: this.chatSessions,
      messages: this.messages,
      deployments: this.deployments,
      environmentVariables: this.environmentVariables,
      checkpoints: this.checkpoints
    }
    
    const targetMap = tableMap[tableName]
    if (!targetMap) {
      console.warn(`Unknown table ${tableName} for import`)
      return
    }
    
    // Clear existing data for this table
    targetMap.clear()
    
    // Import new data
    data.forEach(item => {
      if (item.id) {
        targetMap.set(item.id, item)
      }
    })
  }

  async listTables(): Promise<string[]> {
    return ['workspaces', 'files', 'chatSessions', 'messages', 'deployments', 'environmentVariables', 'tokens']
  }

  async getTableSchema(tableName: string): Promise<any> {
    return { name: tableName, type: 'in-memory' }
  }

  async getAllEntries(tableName: string): Promise<any[]> {
    return this.exportTable(tableName)
  }

  async runQuery(tableName: string, query: string): Promise<any> {
    // Simple query implementation for in-memory storage
    const data = await this.exportTable(tableName)
    return { results: data, query }
  }

  // Add this method to the InMemoryStorage class
  async deleteMessagesAfter(chatSessionId: string, timestamp: string): Promise<number> {
    let deletedCount = 0
    this.messages.forEach((message, id) => {
      if (message.chatSessionId === chatSessionId && message.createdAt > timestamp) {
        this.messages.delete(id)
        deletedCount++
      }
    })
    return deletedCount
  }

  // Checkpoint methods
  async createCheckpoint(checkpoint: Omit<Checkpoint, 'id' | 'createdAt'>): Promise<Checkpoint> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newCheckpoint: Checkpoint = {
      ...checkpoint,
      id,
      createdAt: now
    }
    this.checkpoints.set(id, newCheckpoint)
    return newCheckpoint
  }

  async getCheckpoints(workspaceId: string): Promise<Checkpoint[]> {
    return Array.from(this.checkpoints.values()).filter(c => c.workspaceId === workspaceId)
  }

  async getCheckpoint(id: string): Promise<Checkpoint | null> {
    return this.checkpoints.get(id) || null
  }

  async deleteCheckpoint(id: string): Promise<boolean> {
    return this.checkpoints.delete(id)
  }

  async restoreCheckpoint(checkpointId: string): Promise<boolean> {
    const checkpoint = this.checkpoints.get(checkpointId)
    if (!checkpoint) return false

    // Delete all current files in the workspace
    const currentFiles = Array.from(this.files.values()).filter(f => f.workspaceId === checkpoint.workspaceId)
    currentFiles.forEach(file => this.files.delete(file.id))

    // Restore files from checkpoint
    checkpoint.files.forEach(fileData => {
      const id = this.generateId()
      const restoredFile: File = {
        ...fileData,
        id,
        workspaceId: checkpoint.workspaceId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        type: fileData.fileType // Add the missing 'type' property
      }
      this.files.set(id, restoredFile)
    })

    return true
  }

  // Conversation memory methods
  async createConversationMemory(memory: Omit<ConversationMemory, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationMemory> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newMemory: ConversationMemory = {
      ...memory,
      id,
      createdAt: now,
      updatedAt: now
    }
    this.conversationMemories.set(id, newMemory)
    return newMemory
  }

  async getConversationMemory(projectId: string, userId: string): Promise<ConversationMemory | null> {
    // Find memory by projectId and userId combination
    for (const memory of this.conversationMemories.values()) {
      if (memory.projectId === projectId && memory.userId === userId) {
        return memory
      }
    }
    return null
  }

  async updateConversationMemory(id: string, updates: Partial<ConversationMemory>): Promise<ConversationMemory | null> {
    const memory = this.conversationMemories.get(id)
    if (!memory) return null
    
    const updatedMemory: ConversationMemory = {
      ...memory,
      ...updates,
      updatedAt: new Date().toISOString()
    }
    this.conversationMemories.set(id, updatedMemory)
    return updatedMemory
  }

  async deleteConversationMemory(id: string): Promise<boolean> {
    return this.conversationMemories.delete(id)
  }

  // Conversation summary methods
  async createConversationSummary(summary: Omit<ConversationSummary, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationSummary> {
    const id = this.generateId()
    const now = new Date().toISOString()
    const newSummary: ConversationSummary = {
      ...summary,
      id,
      createdAt: now,
      updatedAt: now
    }
    this.conversationSummaries.set(id, newSummary)
    return newSummary
  }

  async getConversationSummary(projectId: string, userId: string): Promise<ConversationSummary | null> {
    // Find summary by projectId and userId combination
    for (const summary of this.conversationSummaries.values()) {
      if (summary.projectId === projectId && summary.userId === userId) {
        return summary
      }
    }
    return null
  }

  async updateConversationSummary(id: string, updates: Partial<ConversationSummary>): Promise<ConversationSummary | null> {
    const summary = this.conversationSummaries.get(id)
    if (!summary) return null
    
    const updatedSummary: ConversationSummary = {
      ...summary,
      ...updates,
      updatedAt: new Date().toISOString()
    }
    this.conversationSummaries.set(id, updatedSummary)
    return updatedSummary
  }

  async deleteConversationSummary(id: string): Promise<boolean> {
    return this.conversationSummaries.delete(id)
  }

  // Tool execution tracking methods
  async createToolExecution(execution: Omit<ToolExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<ToolExecution> {
    const id = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    const now = new Date().toISOString()
    const newExecution: ToolExecution = {
      ...execution,
      id,
      createdAt: now,
      updatedAt: now
    }
    this.toolExecutions.set(id, newExecution)
    return newExecution
  }

  async getToolExecution(id: string): Promise<ToolExecution | null> {
    return this.toolExecutions.get(id) || null
  }

  async getToolExecutions(workspaceId: string): Promise<ToolExecution[]> {
    return Array.from(this.toolExecutions.values()).filter(exec => exec.workspaceId === workspaceId)
  }

  async updateToolExecution(id: string, updates: Partial<ToolExecution>): Promise<ToolExecution | null> {
    const existing = this.toolExecutions.get(id)
    if (!existing) return null
    
    const updated = { ...existing, ...updates, updatedAt: new Date().toISOString() }
    this.toolExecutions.set(id, updated)
    return updated
  }

  async deleteToolExecution(id: string): Promise<boolean> {
    return this.toolExecutions.delete(id)
  }

  async findExistingExecution(workspaceId: string, toolName: string, args: Record<string, any>): Promise<ToolExecution | null> {
    const executions = Array.from(this.toolExecutions.values())
    return executions.find(exec => 
      exec.workspaceId === workspaceId && 
      exec.toolName === toolName && 
      JSON.stringify(exec.args) === JSON.stringify(args) &&
      (exec.status === 'completed' || exec.status === 'executing')
    ) || null
  }
}

// Client-side IndexedDB storage
class IndexedDBStorage implements StorageInterface {
  private db: IDBDatabase | null = null
  private dbName = 'PixelPilotDB'
  private version = 13 // Updated version to add conversationSummaries object store

  async init(): Promise<void> {
    if (this.db) return

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        this.db = request.result
        resolve()
      }

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result as IDBDatabase

        // Create object stores if they don't exist
        if (!db.objectStoreNames.contains('workspaces')) {
          const workspaceStore = db.createObjectStore('workspaces', { keyPath: 'id' })
          workspaceStore.createIndex('userId', 'userId', { unique: false })
          workspaceStore.createIndex('slug', 'slug', { unique: true })
        }

        if (!db.objectStoreNames.contains('files')) {
          const fileStore = db.createObjectStore('files', { keyPath: 'id' })
          fileStore.createIndex('workspaceId', 'workspaceId', { unique: false })
          fileStore.createIndex('path', ['workspaceId', 'path'], { unique: true })
        }

        if (!db.objectStoreNames.contains('chatSessions')) {
          const sessionStore = db.createObjectStore('chatSessions', { keyPath: 'id' })
          sessionStore.createIndex('userId', 'userId', { unique: false })
          sessionStore.createIndex('workspaceId', 'workspaceId', { unique: false })
        }

        if (!db.objectStoreNames.contains('messages')) {
          const messageStore = db.createObjectStore('messages', { keyPath: 'id' })
          messageStore.createIndex('chatSessionId', 'chatSessionId', { unique: false })
          messageStore.createIndex('createdAt', 'createdAt', { unique: false })
        }

        if (!db.objectStoreNames.contains('deployments')) {
          const deploymentStore = db.createObjectStore('deployments', { keyPath: 'id' })
          deploymentStore.createIndex('workspaceId', 'workspaceId', { unique: false })
        }

        if (!db.objectStoreNames.contains('environmentVariables')) {
          const envStore = db.createObjectStore('environmentVariables', { keyPath: 'id' })
          envStore.createIndex('workspaceId', 'workspaceId', { unique: false })
        }

        if (!db.objectStoreNames.contains('tokens')) {
          const tokenStore = db.createObjectStore('tokens', { keyPath: 'id' })
          tokenStore.createIndex('userId', 'userId', { unique: false })
          tokenStore.createIndex('provider', 'provider', { unique: false })
        }

        // Create checkpoints store with proper indexing
        if (!db.objectStoreNames.contains('checkpoints')) {
          const checkpointStore = db.createObjectStore('checkpoints', { keyPath: 'id' })
          checkpointStore.createIndex('workspaceId', 'workspaceId', { unique: false })
          checkpointStore.createIndex('messageId', 'messageId', { unique: false })
          checkpointStore.createIndex('createdAt', 'createdAt', { unique: false })
        }

        // Create conversation memory store with proper indexing
        if (!db.objectStoreNames.contains('conversationMemories')) {
          const memoryStore = db.createObjectStore('conversationMemories', { keyPath: 'id' })
          memoryStore.createIndex('projectId', 'projectId', { unique: false })
          memoryStore.createIndex('userId', 'userId', { unique: false })
          memoryStore.createIndex('lastActivity', 'lastActivity', { unique: false })
        }

        // Create conversation summaries store for Codestral-generated summaries
        if (!db.objectStoreNames.contains('conversationSummaries')) {
          const summaryStore = db.createObjectStore('conversationSummaries', { keyPath: 'id' })
          summaryStore.createIndex('projectId', 'projectId', { unique: false })
          summaryStore.createIndex('userId', 'userId', { unique: false })
          summaryStore.createIndex('createdAt', 'createdAt', { unique: false })
        }

        // Create tool executions store for tracking XML command executions
        if (!db.objectStoreNames.contains('toolExecutions')) {
          const executionStore = db.createObjectStore('toolExecutions', { keyPath: 'id' })
          executionStore.createIndex('workspaceId', 'workspaceId', { unique: false })
          executionStore.createIndex('toolName', 'toolName', { unique: false })
          executionStore.createIndex('status', 'status', { unique: false })
          executionStore.createIndex('createdAt', 'createdAt', { unique: false })
        }
      }
    })
  }

  // Workspace methods
  async createWorkspace(workspace: Omit<Workspace, 'id' | 'createdAt' | 'updatedAt'>): Promise<Workspace> {
    if (!this.db) throw new Error('Database not initialized')

    const id = this.generateId()
    const now = new Date().toISOString()
    const newWorkspace: Workspace = {
      ...workspace,
      id,
      createdAt: now,
      updatedAt: now
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['workspaces'], 'readwrite')
      const store = transaction.objectStore('workspaces')
      const request = store.add(newWorkspace)

      request.onsuccess = async () => {
        // Emit event for workspace creation
        await emitStorageEvent('workspaces', 'create', id, newWorkspace, workspace.userId)
        resolve(newWorkspace)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async getWorkspace(id: string): Promise<Workspace | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['workspaces'], 'readonly')
      const store = transaction.objectStore('workspaces')
      const request = store.get(id)

      request.onsuccess = () => resolve(request.result || null)
      request.onerror = () => reject(request.error)
    })
  }

  async getWorkspaces(userId: string): Promise<Workspace[]> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['workspaces'], 'readonly')
      const store = transaction.objectStore('workspaces')
      const index = store.index('userId')
      const request = index.getAll(userId)

      request.onsuccess = () => resolve(request.result || [])
      request.onerror = () => reject(request.error)
    })
  }

  async updateWorkspace(id: string, updates: Partial<Workspace>): Promise<Workspace | null> {
    if (!this.db) throw new Error('Database not initialized')

    const workspace = await this.getWorkspace(id)
    if (!workspace) return null

    const updatedWorkspace: Workspace = {
      ...workspace,
      ...updates,
      updatedAt: new Date().toISOString()
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['workspaces'], 'readwrite')
      const store = transaction.objectStore('workspaces')
      const request = store.put(updatedWorkspace)

      request.onsuccess = async () => {
        // Emit event for workspace update
        await emitStorageEvent('workspaces', 'update', id, updatedWorkspace, workspace.userId)
        resolve(updatedWorkspace)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async deleteWorkspace(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')

    // Get workspace before deletion for event data
    const workspace = await this.getWorkspace(id)

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['workspaces'], 'readwrite')
      const store = transaction.objectStore('workspaces')
      const request = store.delete(id)

      request.onsuccess = async () => {
        // Emit event for workspace deletion
        if (workspace) {
          await emitStorageEvent('workspaces', 'delete', id, workspace, workspace.userId)
        }
        resolve(true)
      }
      request.onerror = () => reject(request.error)
    })
  }

  // File methods
  async createFile(file: Omit<File, 'id' | 'createdAt' | 'updatedAt'>): Promise<File> {
    if (!this.db) throw new Error('Database not initialized')

    const id = this.generateId()
    const now = new Date().toISOString()
    const newFile: File = {
      ...file,
      id,
      createdAt: now,
      updatedAt: now
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['files'], 'readwrite')
      const store = transaction.objectStore('files')
      const request = store.add(newFile)

      request.onsuccess = async () => {
        // Emit event for file creation
        await emitStorageEvent('files', 'create', id, newFile)
        resolve(newFile)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async getFile(workspaceId: string, path: string): Promise<File | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['files'], 'readonly')
      const store = transaction.objectStore('files')
      const request = store.getAll()

      request.onsuccess = () => {
        const files = request.result || []
        const file = files.find(f => f.workspaceId === workspaceId && f.path === path)
        resolve(file || null)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async getFiles(workspaceId: string): Promise<File[]> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['files'], 'readonly')
      const store = transaction.objectStore('files')
      const index = store.index('workspaceId')
      const request = index.getAll(workspaceId)

      request.onsuccess = () => resolve(request.result || [])
      request.onerror = () => reject(request.error)
    })
  }

  async updateFile(workspaceId: string, path: string, updates: Partial<File>): Promise<File | null> {
    if (!this.db) throw new Error('Database not initialized')

    const file = await this.getFile(workspaceId, path)
    if (!file) return null

    const updatedFile: File = {
      ...file,
      ...updates,
      updatedAt: new Date().toISOString()
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['files'], 'readwrite')
      const store = transaction.objectStore('files')
      const request = store.put(updatedFile)

      request.onsuccess = async () => {
        // Emit event for file update
        await emitStorageEvent('files', 'update', file.id, updatedFile)
        resolve(updatedFile)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async deleteFile(workspaceId: string, path: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')

    const file = await this.getFile(workspaceId, path)
    if (!file) return false

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['files'], 'readwrite')
      const store = transaction.objectStore('files')
      const request = store.delete(file.id)

      request.onsuccess = async () => {
        // Emit event for file deletion
        await emitStorageEvent('files', 'delete', file.id, file)
        resolve(true)
      }
      request.onerror = () => reject(request.error)
    })
  }

  // Chat session methods
  async createChatSession(session: Omit<ChatSession, 'id' | 'createdAt' | 'updatedAt'>): Promise<ChatSession> {
    if (!this.db) throw new Error('Database not initialized')

    const id = this.generateId()
    const now = new Date().toISOString()
    const newSession: ChatSession = {
      ...session,
      id,
      createdAt: now,
      updatedAt: now
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['chatSessions'], 'readwrite')
      const store = transaction.objectStore('chatSessions')
      const request = store.add(newSession)

      request.onsuccess = async () => {
        // Emit event for chat session creation
        await emitStorageEvent('chatSessions', 'create', id, newSession, session.userId)
        resolve(newSession)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async getChatSessions(userId: string): Promise<ChatSession[]> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['chatSessions'], 'readonly')
      const store = transaction.objectStore('chatSessions')
      const index = store.index('userId')
      const request = index.getAll(userId)

      request.onsuccess = () => resolve(request.result || [])
      request.onerror = () => reject(request.error)
    })
  }

  async getChatSession(id: string): Promise<ChatSession | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['chatSessions'], 'readonly')
      const store = transaction.objectStore('chatSessions')
      const request = store.get(id)

      request.onsuccess = () => resolve(request.result || null)
      request.onerror = () => reject(request.error)
    })
  }

  async updateChatSession(id: string, updates: Partial<ChatSession>): Promise<ChatSession | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    const chatSession = await this.getChatSession(id)
    if (!chatSession) return null
    
    const updatedChatSession: ChatSession = {
      ...chatSession,
      ...updates,
      updatedAt: new Date().toISOString()
    }
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['chatSessions'], 'readwrite')
      const store = transaction.objectStore('chatSessions')
      const request = store.put(updatedChatSession)

      request.onsuccess = () => resolve(updatedChatSession)
      request.onerror = () => reject(request.error)
    })
  }

  // Message methods
  async createMessage(message: Omit<Message, 'id' | 'createdAt'>): Promise<Message> {
    if (!this.db) throw new Error('Database not initialized')

    const id = this.generateId()
    const now = new Date().toISOString()
    const newMessage: Message = {
      ...message,
      id,
      createdAt: now
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['messages'], 'readwrite')
      const store = transaction.objectStore('messages')
      const request = store.add(newMessage)

      request.onsuccess = async () => {
        // Emit event for message creation
        await emitStorageEvent('messages', 'create', id, newMessage)
        resolve(newMessage)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async getMessages(chatSessionId: string): Promise<Message[]> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['messages'], 'readonly')
      const store = transaction.objectStore('messages')
      const index = store.index('chatSessionId')
      const request = index.getAll(chatSessionId)

      request.onsuccess = () => {
        const messages = request.result || []
        resolve(messages.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()))
      }
      request.onerror = () => reject(request.error)
    })
  }

  // Add deleteMessage function
  async deleteMessage(chatSessionId: string, messageId: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    
    // First, verify that the message belongs to the specified chat session
    const message = await new Promise<Message | null>((resolve, reject) => {
      const transaction = this.db!.transaction(['messages'], 'readonly')
      const store = transaction.objectStore('messages')
      const request = store.get(messageId)
      
      request.onsuccess = () => {
        const msg = request.result
        if (!msg || msg.chatSessionId !== chatSessionId) {
          resolve(null)
        } else {
          resolve(msg)
        }
      }
      request.onerror = () => reject(request.error)
    })
    
    // If message doesn't exist or doesn't belong to the session, return false
    if (!message) {
      return false
    }
    
    // Delete the message
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['messages'], 'readwrite')
      const store = transaction.objectStore('messages')
      const request = store.delete(messageId)
      
      request.onsuccess = () => resolve(true)
      request.onerror = () => reject(request.error)
    })
  }

  // Deployment methods
  async createDeployment(deployment: Omit<Deployment, 'id' | 'createdAt'>): Promise<Deployment> {
    if (!this.db) throw new Error('Database not initialized')
    const id = this.generateId()
    const now = new Date().toISOString()
    const newDeployment: Deployment = {
      ...deployment,
      id,
      createdAt: now
    }
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['deployments'], 'readwrite')
      const store = transaction.objectStore('deployments')
      const request = store.add(newDeployment)
      request.onsuccess = () => resolve(newDeployment)
      request.onerror = () => reject(request.error)
    })
  }
  async getDeployments(workspaceId?: string): Promise<Deployment[]> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['deployments'], 'readonly')
      const store = transaction.objectStore('deployments')
      let request: IDBRequest
      if (workspaceId) {
        const index = store.index('workspaceId')
        request = index.getAll(workspaceId)
      } else {
        request = store.getAll()
      }
      request.onsuccess = () => resolve(request.result || [])
      request.onerror = () => reject(request.error)
    })
  }
  async updateDeployment(id: string, updates: Partial<Deployment>): Promise<Deployment | null> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['deployments'], 'readwrite')
      const store = transaction.objectStore('deployments')
      const getRequest = store.get(id)
      getRequest.onsuccess = () => {
        const deployment = getRequest.result
        if (deployment) {
          const updatedDeployment = { ...deployment, ...updates }
          const putRequest = store.put(updatedDeployment)
          putRequest.onsuccess = () => resolve(updatedDeployment)
          putRequest.onerror = () => reject(putRequest.error)
        } else {
          resolve(null)
        }
      }
      getRequest.onerror = () => reject(getRequest.error)
    })
  }
  async deleteDeployment(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['deployments'], 'readwrite')
      const store = transaction.objectStore('deployments')
      const request = store.delete(id)
      request.onsuccess = () => resolve(true)
      request.onerror = () => reject(request.error)
    })
  }

  // Environment variable methods
  async createEnvironmentVariable(envVar: Omit<EnvironmentVariable, 'id' | 'createdAt' | 'updatedAt'>): Promise<EnvironmentVariable> {
    if (!this.db) throw new Error('Database not initialized')
    const id = this.generateId()
    const now = new Date().toISOString()
    const newEnvVar: EnvironmentVariable = {
      ...envVar,
      id,
      createdAt: now,
      updatedAt: now
    }
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['environmentVariables'], 'readwrite')
      const store = transaction.objectStore('environmentVariables')
      const request = store.add(newEnvVar)
      request.onsuccess = () => resolve(newEnvVar)
      request.onerror = () => reject(request.error)
    })
  }
  // Token methods for IndexedDB
  async createToken(token: Omit<TokenEntry, 'id' | 'createdAt' | 'updatedAt'>): Promise<TokenEntry> {
    if (!this.db) throw new Error('Database not initialized')
    const id = this.generateId()
    const now = new Date().toISOString()
    const newToken: TokenEntry = { ...token, id, createdAt: now, updatedAt: now }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['tokens'], 'readwrite')
      const store = transaction.objectStore('tokens')
      const request = store.add(newToken)
      request.onsuccess = () => resolve(newToken)
      request.onerror = () => reject(request.error)
    })
  }

  async getToken(userId: string, provider: string): Promise<TokenEntry | null> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['tokens'], 'readonly')
      const store = transaction.objectStore('tokens')
      const index = store.index('userId')
      const request = index.getAll(userId)
      request.onsuccess = () => {
        const list = request.result || []
        const found = list.find((t: any) => t.provider === provider)
        resolve(found || null)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async updateToken(id: string, updates: Partial<TokenEntry>): Promise<TokenEntry | null> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['tokens'], 'readwrite')
      const store = transaction.objectStore('tokens')
      const getReq = store.get(id)
      getReq.onsuccess = () => {
        const existing = getReq.result
        if (!existing) return resolve(null)
        const updated = { ...existing, ...updates, updatedAt: new Date().toISOString() }
        const putReq = store.put(updated)
        putReq.onsuccess = () => resolve(updated)
        putReq.onerror = () => reject(putReq.error)
      }
      getReq.onerror = () => reject(getReq.error)
    })
  }

  async deleteToken(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['tokens'], 'readwrite')
      const store = transaction.objectStore('tokens')
      const req = store.delete(id)
      req.onsuccess = () => resolve(true)
      req.onerror = () => reject(req.error)
    })
  }

  async getAllTokens(): Promise<TokenEntry[]> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['tokens'], 'readonly')
      const store = transaction.objectStore('tokens')
      const request = store.getAll()
      request.onsuccess = () => resolve(request.result || [])
      request.onerror = () => reject(request.error)
    })
  }
  async getEnvironmentVariables(workspaceId?: string): Promise<EnvironmentVariable[]> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['environmentVariables'], 'readonly')
      const store = transaction.objectStore('environmentVariables')
      let request: IDBRequest
      if (workspaceId) {
        const index = store.index('workspaceId')
        request = index.getAll(workspaceId)
      } else {
        request = store.getAll()
      }
      request.onsuccess = () => resolve(request.result || [])
      request.onerror = () => reject(request.error)
    })
  }
  async updateEnvironmentVariable(id: string, updates: Partial<EnvironmentVariable>): Promise<EnvironmentVariable | null> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['environmentVariables'], 'readwrite')
      const store = transaction.objectStore('environmentVariables')
      const getRequest = store.get(id)
      getRequest.onsuccess = () => {
        const envVar = getRequest.result
        if (envVar) {
          const updatedEnvVar = { ...envVar, ...updates, updatedAt: new Date().toISOString() }
          const putRequest = store.put(updatedEnvVar)
          putRequest.onsuccess = () => resolve(updatedEnvVar)
          putRequest.onerror = () => reject(putRequest.error)
        } else {
          resolve(null)
        }
      }
      getRequest.onerror = () => reject(getRequest.error)
    })
  }
  async deleteEnvironmentVariable(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['environmentVariables'], 'readwrite')
      const store = transaction.objectStore('environmentVariables')
      const request = store.delete(id)
      request.onsuccess = () => resolve(true)
      request.onerror = () => reject(request.error)
    })
  }

  // Admin methods
  async listTables(): Promise<string[]> {
    if (!this.db) await this.init();
    return Array.from(this.db!.objectStoreNames);
  }

  async getTableSchema(tableName: string): Promise<any> {
    if (!this.db) await this.init();
    const store = this.db!.transaction([tableName], 'readonly').objectStore(tableName);
    return {
      name: tableName,
      keyPath: store.keyPath,
      autoIncrement: store.autoIncrement,
      indexes: Array.from(store.indexNames).map(idx => {
        const index = store.index(idx);
        return { name: idx, keyPath: index.keyPath, multiEntry: index.multiEntry, unique: index.unique };
      })
    };
  }

  async getAllEntries(tableName: string): Promise<any[]> {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([tableName], 'readonly');
      const store = transaction.objectStore(tableName);
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }

  async runQuery(tableName: string, query: string): Promise<any> {
    // Simple query implementation for in-memory storage
    const all = await this.getAllEntries(tableName);
    if (!query.trim()) return all;
    const [key, val] = query.split('=');
    if (!key || val === undefined) throw new Error('Invalid query');
    const value = val.trim().replace(/^'|'$/g, '');
    return all.filter(row => String(row[key.trim()]) === value);
  }

  async exportTable(tableName: string): Promise<any[]> {
    return this.getAllEntries(tableName);
  }

  // Removed duplicate importTable method to fix TypeScript error
  // async importTable(tableName: string, data: any[]): Promise<void> {
  //   if (!this.db) await this.init();
  //   return new Promise((resolve, reject) => {
  //     const transaction = this.db!.transaction([tableName], 'readwrite');
  //     const store = transaction.objectStore(tableName);
  //     let completed = 0;
  //     data.forEach(entry => {
  //       const req = store.put(entry);
  //       req.onsuccess = () => {
  //         completed++;
  //         if (completed === data.length) resolve();
  //       };
  //       req.onerror = () => reject(req.error);
  //     });
  //   });
  // }

  // Utility methods
  async clearAll(): Promise<void> {
  if (!this.db) throw new Error('Database not initialized')
    return new Promise((resolve, reject) => {
      const storeNames = ['workspaces', 'files', 'chatSessions', 'messages', 'deployments', 'environmentVariables']
      const transaction = this.db!.transaction(storeNames, 'readwrite')
      let cleared = 0
      storeNames.forEach(storeName => {
        const store = transaction.objectStore(storeName)
        const request = store.clear()
        request.onsuccess = () => {
          cleared++
          if (cleared === storeNames.length) resolve()
        }
        request.onerror = () => reject(request.error)
      })
    })
  }
  async exportData(): Promise<any> {
    if (!this.db) throw new Error('Database not initialized')
    
    // Get all data from all tables
    const [workspaces, files, chatSessions, messages, deployments, environmentVariables, tokens] = await Promise.all([
      this.getAllEntries('workspaces'),
      this.getAllEntries('files'),
      this.getAllEntries('chatSessions'),
      this.getAllEntries('messages'),
      this.getDeployments(), // This already gets all deployments when no workspaceId is provided
      this.getEnvironmentVariables(), // This already gets all environment variables when no workspaceId is provided
      this.getAllTokens()
    ])
    
    return { workspaces, files, chatSessions, messages, deployments, environmentVariables, tokens }
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36)
  }

  // Add this method to the IndexedDBStorage class
  async deleteMessagesAfter(chatSessionId: string, timestamp: string): Promise<number> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['messages'], 'readwrite')
      const store = transaction.objectStore('messages')
      const index = store.index('chatSessionId')
      
      // Get all messages for this session
      const getRequest = index.getAll(chatSessionId)
      
      getRequest.onsuccess = () => {
        const messages = getRequest.result || []
        const messagesToDelete = messages.filter((msg: any) => msg.createdAt > timestamp)
        
        let deletedCount = 0
        if (messagesToDelete.length === 0) {
          resolve(0)
          return
        }
        
        messagesToDelete.forEach((msg: any) => {
          const deleteRequest = store.delete(msg.id)
          deleteRequest.onsuccess = () => {
            deletedCount++
            if (deletedCount === messagesToDelete.length) {
              resolve(messagesToDelete.length)
            }
          }
          deleteRequest.onerror = () => reject(deleteRequest.error)
        })
      }
      
      getRequest.onerror = () => reject(getRequest.error)
    })
  }

  // Checkpoint methods
  async createCheckpoint(checkpoint: Omit<Checkpoint, 'id' | 'createdAt'>): Promise<Checkpoint> {
    if (!this.db) throw new Error('Database not initialized')
    
    const id = this.generateId()
    const now = new Date().toISOString()
    const newCheckpoint: Checkpoint = {
      ...checkpoint,
      id,
      createdAt: now
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['checkpoints'], 'readwrite')
      const store = transaction.objectStore('checkpoints')
      const request = store.add(newCheckpoint)

      request.onsuccess = () => resolve(newCheckpoint)
      request.onerror = () => reject(request.error)
    })
  }

  async getCheckpoints(workspaceId: string): Promise<Checkpoint[]> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['checkpoints'], 'readonly')
      const store = transaction.objectStore('checkpoints')
      const index = store.index('workspaceId')
      const request = index.getAll(workspaceId)

      request.onsuccess = () => {
        // Sort checkpoints by creation time, newest first
        const checkpoints = (request.result || []).sort((a, b) => 
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        )
        resolve(checkpoints)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async getCheckpoint(id: string): Promise<Checkpoint | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['checkpoints'], 'readonly')
      const store = transaction.objectStore('checkpoints')
      const request = store.get(id)

      request.onsuccess = () => resolve(request.result || null)
      request.onerror = () => reject(request.error)
    })
  }

  async deleteCheckpoint(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['checkpoints'], 'readwrite')
      const store = transaction.objectStore('checkpoints')
      const request = store.delete(id)
      request.onsuccess = () => resolve(true)
      request.onerror = () => reject(request.error)
    })
  }

  async restoreCheckpoint(checkpointId: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    
    const checkpoint = await this.getCheckpoint(checkpointId)
    if (!checkpoint) return false

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['files', 'checkpoints'], 'readwrite')
      const fileStore = transaction.objectStore('files')
      
      // Delete all current files in the workspace
      const fileIndex = fileStore.index('workspaceId')
      const deleteRequest = fileIndex.getAllKeys(checkpoint.workspaceId)
      
      deleteRequest.onsuccess = () => {
        const fileKeys = deleteRequest.result || []
        let deleteCount = 0
        
        if (fileKeys.length === 0) {
          // No files to delete, proceed with restoration
          restoreFiles()
          return
        }
        
        fileKeys.forEach(key => {
          const deleteReq = fileStore.delete(key)
          deleteReq.onsuccess = () => {
            deleteCount++
            if (deleteCount === fileKeys.length) {
              restoreFiles()
            }
          }
          deleteReq.onerror = () => reject(deleteReq.error)
        })
      }
      
      deleteRequest.onerror = () => reject(deleteRequest.error)
      
      const restoreFiles = () => {
        // Restore files from checkpoint
        let restoreCount = 0
        if (checkpoint.files.length === 0) {
          resolve(true)
          return
        }
        
        checkpoint.files.forEach(fileData => {
          const id = this.generateId()
          const restoredFile: File = {
            ...fileData,
            id,
            workspaceId: checkpoint.workspaceId,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            type: fileData.fileType // Add the missing 'type' property
          }
          
          const addRequest = fileStore.add(restoredFile)
          addRequest.onsuccess = () => {
            restoreCount++
            if (restoreCount === checkpoint.files.length) {
              resolve(true)
            }
          }
          addRequest.onerror = () => reject(addRequest.error)
        })
      }
    })
  }

  /**
   * Import data into a specific table
   */
  async importTable(tableName: string, data: any[]): Promise<void> {
    if (!this.db) throw new Error('Database not initialized')
    
    // Skip if no data to import
    if (!data || data.length === 0) return

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([tableName], 'readwrite')
      const store = transaction.objectStore(tableName)
      
      let importedCount = 0
      const totalItems = data.length
      
      // Add each item to the store
      data.forEach(item => {
        const request = store.add(item)
        
        request.onsuccess = () => {
          importedCount++
          if (importedCount === totalItems) {
            resolve()
          }
        }
        
        request.onerror = (event) => {
          console.error(`Error importing item to ${tableName}:`, event)
          reject(new Error(`Failed to import item to ${tableName}`))
        }
      })
      
      // Handle case where data array is empty
      if (totalItems === 0) {
        resolve()
      }
    })
  }

  // Conversation memory methods for IndexedDB
  async createConversationMemory(memory: Omit<ConversationMemory, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationMemory> {
    if (!this.db) throw new Error('Database not initialized')
    
    const id = this.generateId()
    const now = new Date().toISOString()
    const newMemory: ConversationMemory = {
      ...memory,
      id,
      createdAt: now,
      updatedAt: now
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationMemories'], 'readwrite')
      const store = transaction.objectStore('conversationMemories')
      const request = store.add(newMemory)

      request.onsuccess = () => resolve(newMemory)
      request.onerror = () => reject(request.error)
    })
  }

  async getConversationMemory(projectId: string, userId: string): Promise<ConversationMemory | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationMemories'], 'readonly')
      const store = transaction.objectStore('conversationMemories')
      const index = store.index('projectId')
      const request = index.getAll(projectId)

      request.onsuccess = () => {
        const memories = request.result || []
        // Find memory that matches both projectId and userId
        const memory = memories.find(m => m.userId === userId)
        resolve(memory || null)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async updateConversationMemory(id: string, updates: Partial<ConversationMemory>): Promise<ConversationMemory | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationMemories'], 'readwrite')
      const store = transaction.objectStore('conversationMemories')
      const getRequest = store.get(id)
      
      getRequest.onsuccess = () => {
        const memory = getRequest.result
        if (memory) {
          const updatedMemory = { ...memory, ...updates, updatedAt: new Date().toISOString() }
          const putRequest = store.put(updatedMemory)
          putRequest.onsuccess = () => resolve(updatedMemory)
          putRequest.onerror = () => reject(putRequest.error)
        } else {
          resolve(null)
        }
      }
      getRequest.onerror = () => reject(getRequest.error)
    })
  }

  async deleteConversationMemory(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationMemories'], 'readwrite')
      const store = transaction.objectStore('conversationMemories')
      const request = store.delete(id)
      
      request.onsuccess = () => resolve(true)
      request.onerror = () => reject(request.error)
    })
  }

  // Conversation summary methods for IndexedDB
  async createConversationSummary(summary: Omit<ConversationSummary, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationSummary> {
    if (!this.db) throw new Error('Database not initialized')
    
    const id = this.generateId()
    const now = new Date().toISOString()
    const newSummary: ConversationSummary = {
      ...summary,
      id,
      createdAt: now,
      updatedAt: now
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationSummaries'], 'readwrite')
      const store = transaction.objectStore('conversationSummaries')
      const request = store.add(newSummary)

      request.onsuccess = () => resolve(newSummary)
      request.onerror = () => reject(request.error)
    })
  }

  async getConversationSummary(projectId: string, userId: string): Promise<ConversationSummary | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationSummaries'], 'readonly')
      const store = transaction.objectStore('conversationSummaries')
      const index = store.index('projectId')
      const request = index.getAll(projectId)

      request.onsuccess = () => {
        const summaries = request.result || []
        // Find summary that matches both projectId and userId
        const summary = summaries.find(s => s.userId === userId)
        resolve(summary || null)
      }
      request.onerror = () => reject(request.error)
    })
  }

  async updateConversationSummary(id: string, updates: Partial<ConversationSummary>): Promise<ConversationSummary | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationSummaries'], 'readwrite')
      const store = transaction.objectStore('conversationSummaries')
      const getRequest = store.get(id)
      
      getRequest.onsuccess = () => {
        const summary = getRequest.result
        if (summary) {
          const updatedSummary = { ...summary, ...updates, updatedAt: new Date().toISOString() }
          const putRequest = store.put(updatedSummary)
          putRequest.onsuccess = () => resolve(updatedSummary)
          putRequest.onerror = () => reject(putRequest.error)
        } else {
          resolve(null)
        }
      }
      getRequest.onerror = () => reject(getRequest.error)
    })
  }

  async deleteConversationSummary(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['conversationSummaries'], 'readwrite')
      const store = transaction.objectStore('conversationSummaries')
      const request = store.delete(id)
      
      request.onsuccess = () => resolve(true)
      request.onerror = () => reject(request.error)
    })
  }

  // Tool execution tracking methods
  async createToolExecution(execution: Omit<ToolExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<ToolExecution> {
    if (!this.db) throw new Error('Database not initialized')
    
    const id = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    const now = new Date().toISOString()
    const newExecution: ToolExecution = {
      ...execution,
      id,
      createdAt: now,
      updatedAt: now
    }
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['toolExecutions'], 'readwrite')
      const store = transaction.objectStore('toolExecutions')
      const request = store.add(newExecution)
      
      request.onsuccess = () => resolve(newExecution)
      request.onerror = () => reject(request.error)
    })
  }

  async getToolExecution(id: string): Promise<ToolExecution | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['toolExecutions'], 'readonly')
      const store = transaction.objectStore('toolExecutions')
      const request = store.get(id)
      
      request.onsuccess = () => resolve(request.result || null)
      request.onerror = () => reject(request.error)
    })
  }

  async getToolExecutions(workspaceId: string): Promise<ToolExecution[]> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['toolExecutions'], 'readonly')
      const store = transaction.objectStore('toolExecutions')
      const index = store.index('workspaceId')
      const request = index.getAll(workspaceId)
      
      request.onsuccess = () => resolve(request.result || [])
      request.onerror = () => reject(request.error)
    })
  }

  async updateToolExecution(id: string, updates: Partial<ToolExecution>): Promise<ToolExecution | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['toolExecutions'], 'readwrite')
      const store = transaction.objectStore('toolExecutions')
      const getRequest = store.get(id)
      
      getRequest.onsuccess = () => {
        const existing = getRequest.result
        if (!existing) {
          resolve(null)
          return
        }
        
        const updated = { ...existing, ...updates, updatedAt: new Date().toISOString() }
        const putRequest = store.put(updated)
        
        putRequest.onsuccess = () => resolve(updated)
        putRequest.onerror = () => reject(putRequest.error)
      }
      getRequest.onerror = () => reject(getRequest.error)
    })
  }

  async deleteToolExecution(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['toolExecutions'], 'readwrite')
      const store = transaction.objectStore('toolExecutions')
      const request = store.delete(id)
      
      request.onsuccess = () => resolve(true)
      request.onerror = () => reject(request.error)
    })
  }

  async findExistingExecution(workspaceId: string, toolName: string, args: Record<string, any>): Promise<ToolExecution | null> {
    if (!this.db) throw new Error('Database not initialized')
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['toolExecutions'], 'readonly')
      const store = transaction.objectStore('toolExecutions')
      const index = store.index('workspaceId')
      const request = index.getAll(workspaceId)
      
      request.onsuccess = () => {
        const executions = request.result || []
        const existing = executions.find(exec => 
          exec.toolName === toolName && 
          JSON.stringify(exec.args) === JSON.stringify(args) &&
          (exec.status === 'completed' || exec.status === 'executing')
        )
        resolve(existing || null)
      }
      request.onerror = () => reject(request.error)
    })
  }
}

// Universal storage manager
class StorageManager {
  async exportTable(tableName: string): Promise<any[]> {
    await this.init();
    return this.storage!.exportTable(tableName);
  }
  private storage: IndexedDBStorage | InMemoryStorage | null = null
  private isInitializing = false
  private isInitialized = false
  private initPromise: Promise<void> | null = null

  constructor() {
    // Detect environment and use appropriate storage
    if (typeof window !== 'undefined' && typeof indexedDB !== 'undefined') {
      // Client-side: use IndexedDB
      this.storage = new IndexedDBStorage()
    } else {
      // Server-side: use in-memory storage
      this.storage = InMemoryStorage.getInstance()
    }
  }

  async init(): Promise<void> {
    if (this.isInitialized) return
    
    if (!this.storage) {
      // Fallback initialization with environment detection
      if (typeof window !== 'undefined' && typeof indexedDB !== 'undefined') {
        this.storage = new IndexedDBStorage()
      } else {
        this.storage = InMemoryStorage.getInstance()
      }
    }
    
    await this.storage.init()
    this.isInitialized = true
  }

  // Workspace methods
  async createWorkspace(workspace: Omit<Workspace, 'id' | 'createdAt' | 'updatedAt'>): Promise<Workspace> {
    await this.init()
    return this.storage!.createWorkspace(workspace)
  }

  async getWorkspace(id: string): Promise<Workspace | null> {
    await this.init()
    return this.storage!.getWorkspace(id)
  }

  async getWorkspaces(userId: string): Promise<Workspace[]> {
    await this.init()
    return this.storage!.getWorkspaces(userId)
  }

  async updateWorkspace(id: string, updates: Partial<Workspace>): Promise<Workspace | null> {
    await this.init()
    return this.storage!.updateWorkspace(id, updates)
  }

  async deleteWorkspace(id: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteWorkspace(id)
  }

  // File methods
  async createFile(file: Omit<File, 'id' | 'createdAt' | 'updatedAt'>): Promise<File> {
    await this.init()
    return this.storage!.createFile(file)
  }

  async getFile(workspaceId: string, path: string): Promise<File | null> {
    await this.init()
    return this.storage!.getFile(workspaceId, path)
  }

  async getFiles(workspaceId: string): Promise<File[]> {
    await this.init()
    return this.storage!.getFiles(workspaceId)
  }

  async updateFile(workspaceId: string, path: string, updates: Partial<File>): Promise<File | null> {
    await this.init()
    return this.storage!.updateFile(workspaceId, path, updates)
  }

  async deleteFile(workspaceId: string, path: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteFile(workspaceId, path)
  }

  // Chat session methods
  async createChatSession(session: Omit<ChatSession, 'id' | 'createdAt' | 'updatedAt'>): Promise<ChatSession> {
    await this.init()
    return this.storage!.createChatSession(session)
  }

  async getChatSessions(userId: string): Promise<ChatSession[]> {
    await this.init()
    return this.storage!.getChatSessions(userId)
  }

  async getChatSession(id: string): Promise<ChatSession | null> {
    await this.init()
    return this.storage!.getChatSession(id)
  }

  async updateChatSession(id: string, updates: Partial<ChatSession>): Promise<ChatSession | null> {
    await this.init()
    return this.storage!.updateChatSession(id, updates)
  }

  // Message methods
  async createMessage(message: Omit<Message, 'id' | 'createdAt'>): Promise<Message> {
    await this.init()
    return this.storage!.createMessage(message)
  }

  async getMessages(chatSessionId: string): Promise<Message[]> {
    await this.init()
    return this.storage!.getMessages(chatSessionId)
  }

  // Add deleteMessage function
  async deleteMessage(chatSessionId: string, messageId: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteMessage(chatSessionId, messageId)
  }

  // Deployment methods
  async createDeployment(deployment: Omit<Deployment, 'id' | 'createdAt'>): Promise<Deployment> {
    await this.init()
    return this.storage!.createDeployment(deployment)
  }

  async getDeployments(workspaceId?: string): Promise<Deployment[]> {
    await this.init()
    return this.storage!.getDeployments(workspaceId)
  }

  async updateDeployment(id: string, updates: Partial<Deployment>): Promise<Deployment | null> {
    await this.init()
    return this.storage!.updateDeployment(id, updates)
  }

  async deleteDeployment(id: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteDeployment(id)
  }

  // Environment variable methods
  async createEnvironmentVariable(envVar: Omit<EnvironmentVariable, 'id' | 'createdAt' | 'updatedAt'>): Promise<EnvironmentVariable> {
    await this.init()
    return this.storage!.createEnvironmentVariable(envVar)
  }

  async getEnvironmentVariables(workspaceId?: string): Promise<EnvironmentVariable[]> {
    await this.init()
    return this.storage!.getEnvironmentVariables(workspaceId)
  }

  async updateEnvironmentVariable(id: string, updates: Partial<EnvironmentVariable>): Promise<EnvironmentVariable | null> {
    await this.init()
    return this.storage!.updateEnvironmentVariable(id, updates)
  }

  async deleteEnvironmentVariable(id: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteEnvironmentVariable(id)
  }

  // Token proxy methods
  async createToken(token: Omit<TokenEntry, 'id' | 'createdAt' | 'updatedAt'>): Promise<TokenEntry> {
    await this.init()
    // @ts-ignore
    return this.storage!.createToken(token)
  }

  async getToken(userId: string, provider: string): Promise<TokenEntry | null> {
    await this.init()
    // @ts-ignore
    return this.storage!.getToken(userId, provider)
  }

  async updateToken(id: string, updates: Partial<TokenEntry>): Promise<TokenEntry | null> {
    await this.init()
    // @ts-ignore
    return this.storage!.updateToken(id, updates)
  }

  async deleteToken(id: string): Promise<boolean> {
    await this.init()
    // @ts-ignore
    return this.storage!.deleteToken(id)
  }

  // Utility methods
  async clearAll(): Promise<void> {
    await this.init()
    return this.storage!.clearAll()
  }

  async exportData(): Promise<any> {
    await this.init()
    return this.storage!.exportData()
  }

  async listTables(): Promise<string[]> {
    await this.init();
    return this.storage!.listTables();
  }

  async getTableSchema(tableName: string): Promise<any> {
    await this.init();
    return this.storage!.getTableSchema(tableName);
  }

  async getAllEntries(tableName: string): Promise<any[]> {
    await this.init();
    return this.storage!.getAllEntries(tableName);
  }

  async runQuery(tableName: string, query: string): Promise<any> {
    await this.init();
    return this.storage!.runQuery(tableName, query);
  }

  // Add this method to the StorageManager class
  async deleteMessagesAfter(chatSessionId: string, timestamp: string): Promise<number> {
    await this.init()
    return this.storage!.deleteMessagesAfter(chatSessionId, timestamp)
  }

  // Checkpoint methods
  async createCheckpoint(checkpoint: Omit<Checkpoint, 'id' | 'createdAt'>): Promise<Checkpoint> {
    await this.init()
    return this.storage!.createCheckpoint(checkpoint)
  }

  async getCheckpoints(workspaceId: string): Promise<Checkpoint[]> {
    await this.init()
    return this.storage!.getCheckpoints(workspaceId)
  }

  async getCheckpoint(id: string): Promise<Checkpoint | null> {
    await this.init()
    return this.storage!.getCheckpoint(id)
  }

  async deleteCheckpoint(id: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteCheckpoint(id)
  }

  async restoreCheckpoint(checkpointId: string): Promise<boolean> {
    await this.init()
    return this.storage!.restoreCheckpoint(checkpointId)
  }

  // Conversation memory methods
  async createConversationMemory(memory: Omit<ConversationMemory, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationMemory> {
    await this.init()
    return this.storage!.createConversationMemory(memory)
  }

  async getConversationMemory(projectId: string, userId: string): Promise<ConversationMemory | null> {
    await this.init()
    return this.storage!.getConversationMemory(projectId, userId)
  }

  async updateConversationMemory(id: string, updates: Partial<ConversationMemory>): Promise<ConversationMemory | null> {
    await this.init()
    return this.storage!.updateConversationMemory(id, updates)
  }

  async deleteConversationMemory(id: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteConversationMemory(id)
  }

  // Conversation summary methods
  async createConversationSummary(summary: Omit<ConversationSummary, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationSummary> {
    await this.init()
    return this.storage!.createConversationSummary(summary)
  }

  async getConversationSummary(projectId: string, userId: string): Promise<ConversationSummary | null> {
    await this.init()
    return this.storage!.getConversationSummary(projectId, userId)
  }

  async updateConversationSummary(id: string, updates: Partial<ConversationSummary>): Promise<ConversationSummary | null> {
    await this.init()
    return this.storage!.updateConversationSummary(id, updates)
  }

  async deleteConversationSummary(id: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteConversationSummary(id)
  }

  // Tool execution tracking methods
  async createToolExecution(execution: Omit<ToolExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<ToolExecution> {
    await this.init()
    return this.storage!.createToolExecution(execution)
  }

  async getToolExecution(id: string): Promise<ToolExecution | null> {
    await this.init()
    return this.storage!.getToolExecution(id)
  }

  async getToolExecutions(workspaceId: string): Promise<ToolExecution[]> {
    await this.init()
    return this.storage!.getToolExecutions(workspaceId)
  }

  async updateToolExecution(id: string, updates: Partial<ToolExecution>): Promise<ToolExecution | null> {
    await this.init()
    return this.storage!.updateToolExecution(id, updates)
  }

  async deleteToolExecution(id: string): Promise<boolean> {
    await this.init()
    return this.storage!.deleteToolExecution(id)
  }

  async findExistingExecution(workspaceId: string, toolName: string, args: Record<string, any>): Promise<ToolExecution | null> {
    await this.init()
    return this.storage!.findExistingExecution(workspaceId, toolName, args)
  }

  /**
   * Import data into a specific table
   */
  async importTable(tableName: string, data: any[]): Promise<void> {
    await this.init();
    return this.storage!.importTable(tableName, data);
  }
}

// Export singleton instance
export const storageManager = new StorageManager()

// Export types for backward compatibility
export type { Workspace as Project } from './storage-manager'
